<!DOCTYPE html>
<html>
<head>
    <title>Game Map 2000x2000</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #f0f0f0;
            font-family: Arial, sans-serif;
        }

        #mapCanvas {
            display: block;
            cursor: grab;
        }

        #mapCanvas:active {
            cursor: grabbing;
        }

        .controls {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 1000;
            min-width: 200px;
        }

        .controls h3 {
            margin: 0 0 10px 0;
            color: #333;
        }

        .stats {
            margin: 10px 0;
            font-size: 12px;
            color: #666;
        }

        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 8px 12px;
            margin: 4px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }

        button:hover {
            background: #45a049;
        }

        input[type="range"] {
            width: 100%;
            margin: 10px 0;
        }

        .coordinates {
            position: fixed;
            bottom: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.9);
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            color: #333;
        }
    </style>
</head>
<body>
<div class="controls">
    <h3>üó∫Ô∏è –ö–∞—Ä—Ç–∞: {{ mapWidth }}√ó{{ mapHeight }}</h3>
    <div class="stats">
        –ü—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–π: <span id="obstacleCount">{{ obstacles|length }}</span>
    </div>
    <div>
        <button onclick="zoomIn()">‚ûï –£–≤–µ–ª–∏—á–∏—Ç—å</button>
        <button onclick="zoomOut()">‚ûñ –£–º–µ–Ω—å—à–∏—Ç—å</button>
        <button onclick="resetView()">üéØ –¶–µ–Ω—Ç—Ä–∏—Ä–æ–≤–∞—Ç—å</button>
    </div>
    <div>
        <input type="range" id="zoomSlider" min="1" max="20" value="5" step="1">
        <div>–ú–∞—Å—à—Ç–∞–±: <span id="zoomLevel">5x</span></div>
    </div>
</div>

<div class="coordinates" id="coordinates">
    X: 0, Y: 0
</div>

<canvas id="mapCanvas"></canvas>

<script>
    // –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
    const BASE_CELL_SIZE = 1; // –ë–∞–∑–æ–≤—ã–π —Ä–∞–∑–º–µ—Ä –∫–ª–µ—Ç–∫–∏
    let scale = 5; // –ù–∞—á–∞–ª—å–Ω—ã–π –º–∞—Å—à—Ç–∞–±
    let offsetX = 0;
    let offsetY = 0;
    let isDragging = false;
    let lastX, lastY;
    let lastDrawTime = 0;
    const DRAW_THROTTLE = 16; // ~60 FPS

    // –≠–ª–µ–º–µ–Ω—Ç—ã DOM
    const canvas = document.getElementById('mapCanvas');
    const ctx = canvas.getContext('2d');
    const zoomSlider = document.getElementById('zoomSlider');
    const zoomLevel = document.getElementById('zoomLevel');
    const coordsDisplay = document.getElementById('coordinates');

    // –î–∞–Ω–Ω—ã–µ –∫–∞—Ä—Ç—ã –∏–∑ Twig
    const MAP_WIDTH = {{ mapWidth }};
    const MAP_HEIGHT = {{ mapHeight }};
    const OBSTACLES = {{ obstacles|json_encode|raw }};

    // –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
    console.log(`–ö–∞—Ä—Ç–∞: ${MAP_WIDTH}x${MAP_HEIGHT}`);
    console.log(`–ü—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–π: ${OBSTACLES.length}`);

    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è canvas
    function initCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        drawMap();
    }

    // –û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –æ—Ç—Ä–∏—Å–æ–≤–∫–∏
    function drawMap() {
        const now = Date.now();
        if (now - lastDrawTime < DRAW_THROTTLE) {
            return;
        }
        lastDrawTime = now;

        requestAnimationFrame(() => {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // –û—Ç—Ä–∏—Å–æ–≤–∫–∞ —Å–µ—Ç–∫–∏ (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
            drawGrid();

            // –û—Ç—Ä–∏—Å–æ–≤–∫–∞ –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–π
            drawObstacles();
        });
    }

    // –û—Ç—Ä–∏—Å–æ–≤–∫–∞ —Å–µ—Ç–∫–∏
    function drawGrid() {
        const cellSize = BASE_CELL_SIZE * scale;
        const startX = Math.floor(offsetX / cellSize) * cellSize;
        const startY = Math.floor(offsetY / cellSize) * cellSize;

        ctx.strokeStyle = '#e0e0e0';
        ctx.lineWidth = 0.5;

        // –í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–µ –ª–∏–Ω–∏–∏
        for (let x = startX; x < offsetX + canvas.width; x += cellSize * 10) {
            const screenX = (x - offsetX) * scale;
            ctx.beginPath();
            ctx.moveTo(screenX, 0);
            ctx.lineTo(screenX, canvas.height);
            ctx.stroke();
        }

        // –ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–µ –ª–∏–Ω–∏–∏
        for (let y = startY; y < offsetY + canvas.height; y += cellSize * 10) {
            const screenY = (y - offsetY) * scale;
            ctx.beginPath();
            ctx.moveTo(0, screenY);
            ctx.lineTo(canvas.width, screenY);
            ctx.stroke();
        }
    }

    // –û—Ç—Ä–∏—Å–æ–≤–∫–∞ –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–π
    function drawObstacles() {
        const cellSize = BASE_CELL_SIZE * scale;

        ctx.fillStyle = '#8d6e63'; // –¶–≤–µ—Ç –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–π

        OBSTACLES.forEach(obstacle => {
            const startX = obstacle.start[0];
            const startY = obstacle.start[1];

            obstacle.map.forEach((row, localY) => {
                row.forEach((cell, localX) => {
                    if (cell === 1) {
                        const worldX = startX + localX;
                        const worldY = startY + localY;

                        const screenX = (worldX - offsetX) * scale;
                        const screenY = (worldY - offsetY) * scale;

                        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤–∏–¥–∏–º–æ—Å—Ç–∏
                        if (screenX > -cellSize && screenX < canvas.width + cellSize &&
                            screenY > -cellSize && screenY < canvas.height + cellSize) {
                            ctx.fillRect(
                                screenX,
                                screenY,
                                cellSize,
                                cellSize
                            );
                        }
                    }
                });
            });
        });
    }

    // –ù–∞–≤–∏–≥–∞—Ü–∏—è –º—ã—à—å—é
    canvas.addEventListener('mousedown', (e) => {
        isDragging = true;
        lastX = e.clientX;
        lastY = e.clientY;
        canvas.style.cursor = 'grabbing';
    });

    canvas.addEventListener('mousemove', (e) => {
        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        const worldX = Math.floor(offsetX + mouseX / scale);
        const worldY = Math.floor(offsetY + mouseY / scale);

        coordsDisplay.textContent = `X: ${worldX}, Y: ${worldY}`;

        if (isDragging) {
            const deltaX = (e.clientX - lastX) / scale;
            const deltaY = (e.clientY - lastY) / scale;

            offsetX -= deltaX;
            offsetY -= deltaY;

            // –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏—è
            offsetX = Math.max(0, Math.min(offsetX, MAP_WIDTH - canvas.width / scale));
            offsetY = Math.max(0, Math.min(offsetY, MAP_HEIGHT - canvas.height / scale));

            lastX = e.clientX;
            lastY = e.clientY;

            drawMap();
        }
    });

    canvas.addEventListener('mouseup', () => {
        isDragging = false;
        canvas.style.cursor = 'grab';
    });

    canvas.addEventListener('mouseleave', () => {
        isDragging = false;
        canvas.style.cursor = 'default';
    });

    // –ó—É–º –∫–æ–ª–µ—Å–æ–º –º—ã—à–∏
    canvas.addEventListener('wheel', (e) => {
        e.preventDefault();

        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;

        const worldX = offsetX + mouseX / scale;
        const worldY = offsetY + mouseY / scale;

        if (e.deltaY < 0) {
            scale = Math.min(20, scale + 1);
        } else {
            scale = Math.max(1, scale - 1);
        }

        offsetX = worldX - mouseX / scale;
        offsetY = worldY - mouseY / scale;

        updateZoomUI();
        drawMap();
    });

    // –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∑—É–º–æ–º
    function zoomIn() {
        scale = Math.min(20, scale + 1);
        updateZoomUI();
        drawMap();
    }

    function zoomOut() {
        scale = Math.max(1, scale - 1);
        updateZoomUI();
        drawMap();
    }

    function resetView() {
        scale = 5;
        offsetX = MAP_WIDTH / 2 - canvas.width / (2 * scale);
        offsetY = MAP_HEIGHT / 2 - canvas.height / (2 * scale);
        updateZoomUI();
        drawMap();
    }

    function updateZoomUI() {
        zoomSlider.value = scale;
        zoomLevel.textContent = scale + 'x';
    }

    zoomSlider.addEventListener('input', (e) => {
        scale = parseInt(e.target.value);
        updateZoomUI();
        drawMap();
    });

    // –†–µ—Å–∞–π–∑ –æ–∫–Ω–∞
    window.addEventListener('resize', () => {
        initCanvas();
    });

    // –ì–æ—Ä—è—á–∏–µ –∫–ª–∞–≤–∏—à–∏
    document.addEventListener('keydown', (e) => {
        switch(e.key) {
            case '+':
            case '=':
                zoomIn();
                break;
            case '-':
                zoomOut();
                break;
            case '0':
                resetView();
                break;
            case 'ArrowLeft':
                offsetX -= 50 / scale;
                drawMap();
                break;
            case 'ArrowRight':
                offsetX += 50 / scale;
                drawMap();
                break;
            case 'ArrowUp':
                offsetY -= 50 / scale;
                drawMap();
                break;
            case 'ArrowDown':
                offsetY += 50 / scale;
                drawMap();
                break;
        }
    });

    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
    window.addEventListener('load', () => {
        initCanvas();
        resetView();
        updateZoomUI();
    });
</script>
</body>
</html>
